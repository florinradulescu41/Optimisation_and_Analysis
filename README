/*
 * Tema 2 ASC
 * 2021 Spring
 */

Structura arhivei:

Makefile, solver_blas.c [1], solver_neopt [2], solver_opt [3], grafic [4]
pentru evauarea comparativa si 3 grafice individuale separate [5][6][7].
Fisierele .c mentionate contin implementari diferite ale operatiei din tema,
C = A × B × Bt + At × A = ABBt + AtA, unde se considera matricea rezultat C
si cele doua matrice date ca parametru functiei my_solver A si B, cele trei
fiind matrice patratice de dimensiune N * N cu elemente de tip double, iar A
fiind matrice superior triunghiulara. Se noteaza Xt transpusa matricei X.

[1] solver_blas.c

Descrierea implementarii:
Se folosesc functii din biblioteca cblas.h pentru a realiza operatii diverse
asupra matricelor (inmultiri si adunari) in scopul atingerii rezultatului.
Matricea rezultat C va stoca rezultatele partiale ale primei secvente de
inmultiri, urmand sa ii fie adunata la final cea de a doua secventa. Astfel,
folosind functia cblas_dgemm (parametrii detaliati in comentarii), C ajunge
sa aiba valoarea B * Bt (transpusa lui B nu este calculata explicit, ci se
foloseste un parametru al functiei pentru a anunta modalitatea de calcul).
Apoi, asupra lui C (care are acum valoarea B * Bt) se aplica o inmultire cu
matricea A folosind functia cblas_dtrmm (parametrii explicati in comentarii),
operatie un urma careia valoarea lui C va fi A * B * Bt, adica primul termen
al adunarii din functia initiala. Separat, folosind aceeasi funtie cblas_dtrmm
se calculeaza At * A, inmultindu-se matricea transpusa At la stanga matricei
AtA, ce contine copiata valoarea initiala a lui A, rezultat fiind At * A.
Cei doi termeni, C si AtA sunt adunati la final in matricea C, finala.

[2] solver_neopt.c

Descrierea implementarii:
Varianta neoptimizata contine calculul clasic al inmultirii de matrice in C,
folosind iterari prin bucle for. Prima bucla este folosita pentru a parcurge
liniile matricei B, apoi coloanele din ambele matrice si liniile din a doua
matrice. Totusi, avand in vedere ca a doua matrice din prima bucla imbricata
este o transpusa, parcurgerea ei in ultimul for se face inversand pozitiile
indicilor de linie si coloana (ambele matrice par astfel parcurse "identic").
Diferenta se poate observa la urmatoarea imbricare de clauze de tip for, unde
inmultirea se face clasic. Aceste prime doua imbricari calculeaza, pe rand,
B * Bt in matricea BBt si A * BBt in matricea ABBt. Matricea AtA contine deci
rezultatul inmultirii dintre matricea A cu transpusa ei, caz in care, la fel
ca la inmultirea A * BBt anterioara, se trateaza in mod special cazul descris
in enunt sub forma proprietatii de matrice superior traiunghiulara pe care o
are matricea A. Din aceaza cauza, in ambele iteratii, ultima bucla for este
modificata, iterarea ignorand elementele nule (in primul caz, ea incepe pe
fiecare linie de la coloana cu index imediat superior acelei linii, iar in al
doilea caz oprindu-se la minimul indicelui de linie din matricea A si a celui
de coloana din matricea At, care la randul ei triunghiulara, desi inferior).
Ultima imbricare se foloseste pentru a aduna cei doi termeni, ABBt si AtA in
cadrul matricei intoarsa ca rezultat, C.

[3] solver_opt.c

Descrierea implementarii:
Varianta urmareste aceeasi abordare ca solver_neopt.c, dar cu o eficientizare
adusa procesului de calcul ce face astfel programul sa se execute mai rapid.
Pornind de la observatia ce denota ca in cadrul ultimul bucle de tip for din
imbricarile folosite pentru imnultirea de matrice, se poate trata rezultatul
aflat la un anume indice ca o constanta. Drept urmare, nu se va adauga nicio
valoare la acesta in cadrul iteratiilor, ci abia dupa stabilirea sumei tuturor
coeficientilor implicati. Aceasta suma temporara este tinuta intr-o variabila
de tip registru pentru a eficientiza viteza de accesare a memoriei si scrierea
in cadrul acesteia. Modul in care schimbarea afecteaza timpul de executie al
acestei abordari se poate verifica in cadrul graficului de la punctul [4], in
care se observa un speedup fata de varianta initiala, neoptimizata. O mentiune
importanta este ca optimizarile folosite nu au fost suficiente pentru a reduce
timpul de executie al acestei implementari sub pragul descris ca satisfacator
in cadrul enuntului temei (12 secunde pe coada ibm-nehalem.q pentru testul cu
dimensiunea matricei de N * N = 1200 * 1200 elemente).

[4] grafic

Graficul este folosit ca baza pentru analiza comparativa pe baza de timpi de
rulare intre cele trei variante de implementare mentionate anterior. Astfel,
pentru fiecare dintre variante s-au efectuat pe aceeasi arhitectura un numar
de 6 teste, fiecare test avand o valoare diferita pentru dimensiunea generala
a matricelor de calcul N * N, variind treptat valoarea lui N de la 400 la 1400
cu un pas de 200. S-au obtinut urmatoarele rezultate pentru baza graficului:

BLAS, NEOPT, OPT = rulari folosind solver_blas.c, solver_neopt.c, solver_opt.c.
Time este timpul exprimat in secunde scurs pentru obtinrea rezultatului corect.

N = 400:
BLAS SOLVER Time=0.050631
NEOPT SOLVER Time=1.112644
OPT SOLVER Time=0.746751

N=600:
BLAS SOLVER Time=0.107851
NEOPT SOLVER Time=3.570956
OPT SOLVER Time=2.337827

N=800:
BLAS SOLVER Time=0.202301
NEOPT SOLVER Time=8.536873
OPT SOLVER Time=5.608161

N=1000:
BLAS SOLVER Time=0.383041
NEOPT SOLVER Time=16.422619
OPT SOLVER Time=10.776759

N=1200:
BLAS SOLVER Time=0.652319
NEOPT SOLVER Time=28.680351
OPT SOLVER Time=18.785624

N=1400:
BLAS SOLVER Time=1.029703
NEOPT SOLVER Time=46.510609
OPT SOLVER Time=30.587818

Concluzii: Se poate observa ca rularile folosind functiile din cblas.h tin
considerabil mai putin decat cele folosind variantele clasice, optimizate sau
nu, iar aceasta diferenta este cu atat mai vizibila pe grafic. Cresterea in
timp a rularii variantelor de tip BLAS pentru o progresie de dimensiuni ale
matricelor este aproape o functie liniara, fiind doar aproape dubla cu fiecare
pas fata de varianta anterioara (valoarea fiind foarte mica, factorul dublarii
este aproape insesizabil). Pe de alta parte, in medie, si crestera celorlalte
metode in grafic (NEOPT SI OPT_M) se poate aproxima la o liniaritate dubla,
insa pe un spectru de valori considerabil ridicat, ceea ce le face sa para mai
mult echivalentul unor functii exponentiale. In realitate, se poate vedea cum
fiecare crestere se realizeaza cu uniformitati asemanatoare in celelalte trei
grafice separate incluse pentru fiecare varianta de implementare [5][6][7].
